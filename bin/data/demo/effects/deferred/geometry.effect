<?xml version="1.0" encoding="UTF-8"?>
<Effect>
	<DepthTest>true</DepthTest>
	<FrontFace>CCW</FrontFace>
	<CullFace>BACK</CullFace>
	<DepthFunc>LESS</DepthFunc>
	<VertexShader>
	<![CDATA[
		#version 330
		
		uniform mat4 ModelMatrix;
		uniform mat4 ProjectionMatrix;
		uniform mat4 ViewMatrix;

		// Vertex information
		layout(location = 0) in vec3 position;
		layout(location = 1) in vec3 normal;
		layout(location = 2) in vec2 texcoord;

		// Data to fragment shader
		out vec3 vs_WorldSpaceNormals;
		out vec2 vs_TexCoords;
		out vec4 vs_ViewSpacePosition;

		void main()
		{
			// Calculate the view-space position
			vs_ViewSpacePosition = ViewMatrix * ModelMatrix * vec4(position, 1.0);
			
			// Supply the view-space normal matrix to the fragment shader
			mat4 normalMatrix = transpose(inverse(ModelMatrix));
			vs_WorldSpaceNormals = normalize(vec3(normalMatrix * vec4(normal, 1.0)));
			
			// Send the texture coordinates to the fragment shader
			vs_TexCoords = texcoord;
			
			// Render the vertices at the projected position
			gl_Position = ProjectionMatrix * vs_ViewSpacePosition;
		}
	]]>
	</VertexShader>
	<SamplerState Id="DiffuseTexture">
		<MinFilter>LINEAR</MinFilter>
		<MagFilter>LINEAR</MagFilter>
		<WrapS>REPEAT</WrapS>
		<WrapT>REPEAT</WrapT>
	</SamplerState>
	<FragmentShader>
	<![CDATA[
		#version 330

		// Screen information
		uniform float FarClipDistance;

		// Mesh materials
		uniform sampler2D DiffuseTexture;
		uniform vec3 DiffuseColor;

		// Data from vertex shader
		in vec3 vs_WorldSpaceNormals;
		in vec2 vs_TexCoords;
		in vec4 vs_ViewSpacePosition;

		void main()
		{
			// Color
			gl_FragData[0] = vec4(texture2D(DiffuseTexture, vs_TexCoords).rgb, 0);
			
			// Put the normal and the linearized depth value
			gl_FragData[1] = vec4(normalize(vs_WorldSpaceNormals) * 0.5 + 0.5, -vs_ViewSpacePosition.z / FarClipDistance);
		}
	]]>
	</FragmentShader>
</Effect>