<?xml version="1.0" encoding="UTF-8"?>
<Effect>
	<Blend>true</Blend>
	<SrcFactor>ONE</SrcFactor>
	<DestFactor>ONE</DestFactor>
	<DepthTest>false</DepthTest>
	<FrontFace>CCW</FrontFace>
	<CullFace>FRONT</CullFace>
	<VertexShader>
	<![CDATA[
		#version 330

		uniform mat4 ProjectionMatrix;
		uniform mat4 ViewMatrix;
		uniform mat4 ModelMatrix;

		// Light properties
		uniform float LightRadius;
		uniform vec3 LightPosition;

		layout(location = 0) in vec3 in_Position;
		layout(location = 2) in vec2 in_texCoord;

		out vec2 vs_texCoord;
		out vec3 vs_lightPosInWorldSpace;
		out vec2 vs_screenSpaceTexCoord;

		void main()
		{
			mat4 modelView = ViewMatrix * ModelMatrix;
			
			vec4 texPos = vec4(in_Position.xyz + LightPosition.xyz, 1.0);
			vec4 pos = modelView * texPos;
			pos.xyz += in_Position.xyz * LightRadius;
			
			gl_Position = ProjectionMatrix * pos;
			
			// Don't take billboard rotation into consideration - thus only use ViewMatrix
			vs_lightPosInWorldSpace = vec3(ViewMatrix * vec4(LightPosition, 1.0));
			
			vec3 eyePosition = pos.xyz;
			vec4 screenPos = ProjectionMatrix * vec4(eyePosition, 1.0);
			screenPos /= screenPos.w;
			screenPos.z = (screenPos.z > -1.0) ? screenPos.z : -1.0;
			vs_screenSpaceTexCoord = screenPos.xy * 0.5 + 0.5;
			
			vs_texCoord = in_texCoord;
		}
	]]>
	</VertexShader>
	<SamplerState Id="LightTexture">
		<MinFilter>LINEAR</MinFilter>
		<MagFilter>LINEAR</MagFilter>
		<WrapS>CLAMP_TO_EDGE</WrapS>
		<WrapT>CLAMP_TO_EDGE</WrapT>
	</SamplerState>
	<FragmentShader>
	<![CDATA[
		#version 330

		// Texture samples to decide if the light should be rendered
		uniform sampler2D PositionsTexture;
		uniform sampler2D NormalsTexture;
		uniform sampler2D DiffuseTexture;

		// How the texture looks like
		uniform sampler2D LightTexture;

		// Global ambient color
		//uniform vec3 AmbientColor;

		// Variables used by the point light
		uniform float LightRadius;
		uniform vec3 LightColor;
		uniform vec3 LightPosition;
		uniform float ConstantAttenuation;
		uniform float LinearAttenuation;
		uniform float QuadraticAttenuation;

		// Position of the pixel
		in vec2 vs_texCoord;
		in vec2 vs_screenSpaceTexCoord;
		in vec3 vs_lightPosInWorldSpace;

		//
		// Use: Quadratic Attenuation
		// https://developer.valvesoftware.com/wiki/Constant-Linear-Quadratic_Falloff
		// http://www.lighthouse3d.com/tutorials/glsl-tutorial/point-light-per-pixel/
		// http://blog.slindev.com/2011/01/10/natural-light-attenuation/
		// http://www.paulsprojects.net/opengl/ppatten/ppatten.html
		//

		void main()
		{
			vec4 color = texture2D(LightTexture, vs_texCoord) * vec4(LightColor, 1.0);
			if(color.a == 0)
				discard;
				
			vec3 normal = texture2D(NormalsTexture, vs_screenSpaceTexCoord).xyz * 2.0 - 1.0;
			normal = normalize(normal);
			
			vec4 mat = texture2D(DiffuseTexture, vs_screenSpaceTexCoord);
			vec3 position = texture2D(PositionsTexture, vs_screenSpaceTexCoord).xyz;
			
			vec3 lightDir = vs_lightPosInWorldSpace - position;
			float dist = length(lightDir);
			lightDir /= dist;
			
			float Ia = 1.0 - (dist * dist) / (LightRadius * LightRadius);
					
			gl_FragColor = color * Ia;
			//gl_FragColor = color;// * Ia;
		}
	]]>
	</FragmentShader>
</Effect>